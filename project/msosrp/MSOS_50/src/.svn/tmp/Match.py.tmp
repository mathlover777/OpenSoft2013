import cv2
import numpy as np
import math
from SmithWaterman import *
from GetCandidateMatchSet import *
from merge import *
from transform import *
from GetMergedImage import *
from Fragment import *


n_img=5

image=[None for i in range(0,n_img)]
corrected=[None for i in range(0,n_img)]
kernel = np.ones((5,5),np.uint8)
contours=[[] for i in range(0,n_img)]
new_contours=[None for i in range(0,n_img)]
contour_img=[None for i in range(0,n_img)]
cont=[None for i in range(0,n_img)]
turning=[[] for i in range(0,n_img)]
turn_pts=[[] for i in range(0,n_img)]

F=[]

for i in range(1,n_img):
    image[i]=cv2.imread('test3/i'+str(i)+'.png',0)
    
    image[i]=cv2.GaussianBlur(image[i],(5,5),1)
    
    #Image Thresholding
    ret,threshold = cv2.threshold(image[i],254,255,cv2.THRESH_BINARY_INV)
    
    # Drawing Contours
    open=cv2.morphologyEx(threshold, cv2.MORPH_OPEN, kernel)
    corrected[i]=cv2.morphologyEx(threshold, cv2.MORPH_CLOSE, kernel)
    new_contours[i], hierarchy = cv2.findContours(corrected[i],cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
    

    cont1=np.zeros((1000,1000),np.uint8)
    cv2.drawContours(cont1,new_contours[i],-1,255,1)
    cv2.imshow("Contour",cont1)
    
    height,width= image[i].shape[:2]
    contour_img[i]=np.zeros((height,width,1), np.uint8)
    
    #displayContour("Cont1",new_contours[i])
    
<<<<<<< .mine
    # print(new_contours[i])
=======
    #print(new_contours[i])
>>>>>>> .r101
    for cnt in new_contours[i]:
        if cv2.contourArea(cnt)>50000:
            #displayContour("Contq"+str(cv2.contourArea(cnt)),[cnt])
            contours[i].extend(cnt)
    
    
    #contours[i]=cv2.approxPolyDP(new_contours[i][0],2,True)
    
    #contours[i]=[cnt for cnt in contours[i] if cv2.contourArea(cnt)>50000]
    

    for num in range(3,len(contours[i])-3):
        vector1=(contours[i][num-3][0]-contours[i][num][0])
        vector2=(contours[i][num+3][0]-contours[i][num][0])
        
        #print(vector1)
        
        cos=(vector1[0]*vector2[0]+vector1[1]*vector2[1])/(math.sqrt((math.pow(vector1[0],2)+math.pow(vector1[1],2))*(math.pow(vector2[0],2)+math.pow(vector2[1],2))))
        turn=round(math.acos(cos),100)
        #print(turn)
        #if abs(turn)>=(10*3.14/180) and (abs(turn)<=(170*3.14/180) or abs(turn)>=(190*3.14/180)):
        turning[i].append(turn)
        turn_pts[i].append(contours[i][num])                
        
    
    frag=Fragment()
    frag.turning_angles=turning[i]
    frag.points=contours[i]
    F.append(frag)
    
    
    
    cv2.drawContours(contour_img[i], contours[i], -1, 255, 1)
    cv2.imshow('contour_image'+str(i),contour_img[i])

FragmentList=GetMergedImage(F)

print("Hello")

cont3=np.zeros((1000,1000),np.uint8)

# print(get1N2(FragmentList[0].points))

cv2.drawContours(cont3,get1N2(FragmentList[0].points),-1,255,1)
cv2.imshow("Output",cont3)


#D=GetCandidateMatchSet(F)


k=cv2.waitKey(0)
if(k==27):
    cv2.destroyAllWindows()